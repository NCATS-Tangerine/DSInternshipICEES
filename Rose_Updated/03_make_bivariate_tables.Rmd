---
title: "Make Bivariate Tables"
author: "Perry Haaland"
date: "02/05/2020"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(jsonlite)
library(httr)
```

## Introduction

Eventually we are going to extract a three-way table and the three corresponding two-way tables using the OpenAPI, and the univariate counts for each variable separately. Because we are using the OpenAPI, we are extracting pre-binned data. The extracted values are also subject the privacy constraints of the system in terms of reporting low frequency cell counts.

The univariate counts for each variable are the univariate marginal distribution across the bins. The two-way tables are the bivariate marginal distributions. The three-way table, which is the full multivariate distribution is constrained by its marginal distributions, so we can use those to check on the correctness of the OpenAPI results.

* Before running this chunks in this script, please run the code in `02_make_univariate_tables.Rmd'.

We use the `json` format of the interface. The data set that we aer extracting from is

* Cohort 22 (all patients),
* 2010 data,
* Version 1.0.0 of ICEES.

In this file we extract the bivariate tables. The features that we are working with are as follows:

* Total ED/Inpatient Visits, 
* Average Daily PM 2.5 Exposure, 
* Major Roadway Highway Exposure.

We will extract the three bivariate combinations of the three features (Total ED/Inpatient Visits, Average Daily PM 2.5 Exposure, Major Roadway Highway Exposure) from the ICEES API. We will use the parameters of: Cohort 22 (all patients), year 2010, version 1.0.0 of ICEES data, and patient level data. We will also be using the Hypothesis Driven NxN Feature Association Functionality.

## Revisiting the relevant univariate features

My current understanding of the OpenAPI, is that the request for bivariate tables has to be hard coded specific for each feature. It seems to me that there should be a way to automate this and get all bivariate tables, or at least to get bivariate tables by just giving the feature names. That task may be left to a graduate student when we get one.

In order to do the hard coding, we need to know the bins for each feature. Here is that information. Note that there are 30 rows in the first table. After the first 10 rows, all of the counts are 10 or less. It seems like the higher ones should be binned before proceeding to the two-way tables.


```{r}
## univariate_df was created in the document 02_make_univariate_tables.Rmd
univariate_df %>%
  filter(feature == "TotalEDInpatientVisits")
```


```{r}
univariate_df %>%
  filter(feature == "MaxDailyPM2.5Exposure_qcut")
```


```{r}
univariate_df %>%
  filter(feature == "MajorRoadwayHighwayExposure")
```

## Creating the bivariate tables

In order to make the code clearer, and perhaps pave the way for later automation, we create some variables that will be used in the OpenAPI calls. The first call will be `TotalEDInpatientVisits` versus `MaxDailyPM2.5Exposure_qcut`.

* Note: The range of TotalEDInpatientVisits, as we saw above goes up to 51 visit. Because all of the values of 10 or more are relatively small, we don't expect them to be returned as actual numbers but will be replaced by NA's because of the privacy constraints. So in this example we are just going to ignore the upper range. 

* An alternative to this strategy would be to group all of the 10 visits or above subjects into one group. We leave that as an exercise for the future.

### Table 1. Total ED Inpatient Visits versuys Maximum Daily PM 2.5 Exposure
I picked a generic name for the table, for the time being. There probably should be more internal error checking.

```{r, message=FALSE}
body_table1 ='{
                     "feature_a": {
                     "TotalEDInpatientVisits": [
                     {
                     "operator": "=",
                     "value": 0
                     }, {
                     "operator": "=",
                     "value": 1
                     }, {
                     "operator": "=",
                     "value": 2
                     },{
                     "operator": "=",
                     "value": 3
                      },{
                     "operator": "=",
                    "value": 4
                     }, {
                     "operator": "=",
                     "value": 5
                     }, {
                     "operator": "=",
                     "value": 6
                     }, {
                     "operator": "=",
                     "value": 7
                     }, {
                     "operator": "=",
                     "value": 8
                     }, {
                     "operator": "=",
                      "value": 9
                     }
                     ]
                     },
                     "feature_b": {
                     "MaxDailyPM2.5Exposure_qcut": [
                     {
                     "operator": "=",
                     "value": 1
                     },
                     {
                     "operator": "=",
                     "value": 2
                     },
                     {
                     "operator": "=",
                     "value": 3
                     },
                     {
                     "operator": "=",
                    "value": 4
                     },
                     {
                     "operator": "=",
                     "value": 5
                     }
                     ]
                     }
                     }'
## table1 is what Rose called PM2.5data
table1_call <- httr::POST("https://icees.renci.org/1.0.0/patient/2010/cohort/COHORT%3A22/feature_association2",
                     body = body_table1,
          accept_json(),
          content_type("application/json"),
          encode = "json")
table1_text <- httr::content(table1_call, "text")
table1_list <- jsonlite::fromJSON(table1_text, flatten = TRUE)$`return value`
## have to hard code these values
EDVisits = c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
MaxExposure = c(1, 2, 3, 4, 5)
for(i in 1:5){
  temp_df <- data.frame(EDVisits = EDVisits, 
                        MaxDailyExposure = MaxExposure[i],
                        Frequency = table1_list$feature_matrix[[i]]$frequency)
  if(i == 1) {
    table1_df = temp_df
  } else {
    table1_df <- rbind(table1_df,temp_df)
  }
}
table1_df

```

### Table 2. Total ED Inpatient Visits verus Major Roadway Highway Exposure

The second call will be `TotalEDInpatientVisits` versus `MajorRoadwayHighwayExposure`.

```{r, message=FALSE}
body_table2 ='{
                  "feature_a": {
                  "TotalEDInpatientVisits": [
                     {
                  "operator": "=",
                  "value": 0
                  }, {
                  "operator": "=",
                  "value": 1
                  }, {
                  "operator": "=",
                  "value": 2
                  },{
                  "operator": "=",
                  "value": 3
                  },{
                  "operator": "=",
                  "value": 4
                  }, {
                  "operator": "=",
                  "value": 5
                  }, {
                  "operator": "=",
                  "value": 6
                  },
                  {
                  "operator": "=",
                  "value": 7
                  }, {
                  "operator": "=",
                  "value": 8
                  }, {
                  "operator": "=",
                  "value": 9
                  }
                  ]
                  },
                  "feature_b": {
                  "MajorRoadwayHighwayExposure": [
                  {
                  "operator": "=",
                  "value": 1
                  },
                  {
                  "operator": "=",
                  "value": 2
                  },
                  {
                  "operator": "=",
                  "value": 3
                  },
                  {
                  "operator": "=",
                  "value": 4
                  },
                  {
                  "operator": "=",
                  "value": 5
                  },
                  {
                  "operator": "=",
                  "value": 6
                  }
                  ]
                  }
                  }'
table2_call <- httr::POST("https://icees.renci.org/1.0.0/patient/2010/cohort/COHORT%3A22/feature_association2",
                     body = body_table2,
          accept_json(),
          content_type("application/json"),
          encode = "json")
table2_text <- httr::content(table2_call, "text")
table2_list <- jsonlite::fromJSON(table2_text, flatten = TRUE)$`return value`
## have to hard code these values
EDVisits = c(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)
MaxRoadway = c(1, 2, 3, 4, 5, 6)
for(i in 1:6){
  temp_df <- data.frame(EDVisits = EDVisits, 
                        RoadwayExposure = MaxRoadway[i],
                        Frequency = table2_list$feature_matrix[[i]]$frequency)
  if(i == 1) {
    table2_df = temp_df
  } else {
    table2_df <- rbind(table2_df,temp_df)
  }
}
table2_df
```

### Table 3. Major Roadway Highway Exposure versus Maximum Daily PM2.5 Exposure

The third call will be for `MajorRoadwayHighwayExposure` vs `MaxDailyPM2.5Exposure_qcut`

```{r}
body_table3 ='{
                      "feature_a": {
                      "MajorRoadwayHighwayExposure": [
                      {
                      "operator": "=",
                      "value": 1
                      },
                      {
                      "operator": "=",
                      "value": 2
                      },
                      {
                      "operator": "=",
                      "value": 3
                      },
                      {
                      "operator": "=",
                      "value": 4
                      },
                      {
                      "operator": "=",
                      "value": 5
                      },
                      {
                      "operator": "=",
                      "value": 6
                      }
                      ]
                      },
                      "feature_b": {
                      "MaxDailyPM2.5Exposure_qcut": [
                      {
                      "operator": "=",
                      "value": 1
                      },
                      {
                      "operator": "=",
                      "value": 2
                      },
                      {
                      "operator": "=",
                      "value": 3
                      },
                      {
                      "operator": "=",
                      "value": 4
                      },
                      {
                      "operator": "=",
                      "value": 5
                      }
                      ]
                      }
                      }'
table3_call <- httr::POST("https://icees.renci.org/1.0.0/patient/2010/cohort/COHORT%3A22/feature_association2",
                     body = body_table3,
          accept_json(),
          content_type("application/json"),
          encode = "json")
table3_text <- httr::content(table3_call, "text")
table3_list <- jsonlite::fromJSON(table3_text, flatten = TRUE)$`return value`
## have to hard code these values
MaxRoadway = c(1, 2, 3, 4, 5, 6)
MaxExposure = c(1, 2, 3, 4, 5)
for(i in 1:5){
  temp_df <- data.frame(RoadwayExposure = MaxRoadway, 
                        MaxExposure = MaxExposure[i],
                        Frequency = table3_list$feature_matrix[[i]]$frequency)
  if(i == 1) {
    table3_df = temp_df
  } else {
    table3_df <- rbind(table3_df,temp_df)
  }
}
table3_df
```


## Brief examination of bivariate tables

The first result that surprises me is that the bivariate table returns fequency values for cells which have counts below 10. I thought that 10 was the minimum number required for reporting.

```{r}
table1_df %>%
  arrange(Frequency)
```

Compare the total frequencies reported in the univariate table versus the different bivariate tables

```{r}
univariate_df %>% 
  filter(str_detect(feature, 'MaxDailyPM2.5Exposure_qcut|MajorRoadwayHighwayExposure|TotalEDInpatientVisits')) %>%
  group_by(feature) %>%
  summarize(total_counts = sum(frequency))

```

```{r}
sum(table1_df$Frequency)
```
```{r}
univariate_df %>% 
  filter(str_detect(feature, 'TotalEDInpatientVisits')) %>%
  filter(as.numeric(value) >= 10) %>%
  summarize(total_counts = sum(frequency))
```

We can see that the 57 subjects with 10 or more visits are correctly left out of the bivariate tables based on the total counts.

